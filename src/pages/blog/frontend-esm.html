<h2>Frontend development with TypeScript and libraries, but no bundler</h2>

<p><a href="https://vitejs.dev/">Vite</a>, <a href="https://webpack.js.org/">Webpack</a>, <a href="https://parceljs.org/">Parcel</a>, <a href="https://esbuild.github.io/">esbuild</a>, <a href="https://rollupjs.org/">Rollup</a>, and many more. How many tools one has to know to build a frontend application? What if those tools are not necessary? What if a simple frontend application could be created without those tools?
Let's see how.</p>

{{h3|esm|ESM (ECMAScript modules)}}

<p>
  The first step to do is to use ES modules. 
  In our <code class="code">index.html</code> file we create following content:

  <code class="code-block language-html">
    &#x3C;script type=&#x22;module&#x22; src=&#x22;./main.mjs&#x22;&#x3E;&#x3C;/script&#x3E;
  </code>

  As you can see we are referencing <code class="code">main.mjs</code> file. The <code class="code">mjs</code> extension is a standard to identify ESM file. Also, the script tag has to have <code class="code">type="module"</code>.
</p>

<p>
  Then, we create <code class="code">main.mjs</code> file, and <code class="code">hello-world.mjs</code> file (that we will import using ESM syntax in <code class="code">main.mjs</code> file).

  <code class="code-block language-js">// main.mjs
import { helloWorld } from './hello-world.mjs'; // the extension here is required

helloWorld();
  </code>

  <code class="code-block language-js">// hello-world.mjs
export const helloWorld = () => alert('Hello world!');
  </code>
</p>

<p>
  At this point, the last thing to do is to <i>serve</i> our <code class="code">index.html</code> file. Serving is necessary, because simply opening <code class="code">index.html</code> in the browser directly from the filesystem won't allow us to dynamically import our JavaScript. There are multiple ways to serve static site, however my chosen one for this article is <a href="https://www.npmjs.com/package/serve">serve</a> library:

  <code class="code-block">pnpm add serve
pnpm serve . // the directory where index.html can be found
  </code>

  Upon entering <code class="code">http://localhost:3000</code> (default <code class="code">serve</code> port) the alert is executed as expected:
</p>

{{h3|typescript|TypeScript}}

<p>
  Now, the TypeScript. To have TypeScript working in the browser, we first have to have it working with ESM at all.
</p>

<p>For that, we are going to modify <code class="code">tsconfig.json</code>:</p>

<code class="code-block language-js">// tsconfig.json
{
  "compilerOptions": {
    ...,
    "module": "ESNext", // Set support for ESM
    "outDir": "./public", // Set output directory, from which we are going to serve our JS files 
    ...
  }
}
</code>

<p>Then, the <code class="code">package.json</code>:</p>

<code class="code-block language-js">// package.json
{
  ...,
  "type": "module",
  ...
}
</code>

<p>And finally we have to convert our files' extension from <code class="code">mjs</code> to <code class="code">mts</code>.</p>

<p>At this point, after running <code class="code">tsc</code> compiler, we should get our <code class="code">public</code> directory populated with <code class="code">mjs</code> files ready to be imported in the browser as described in the previous section.</p>

{{h3|libraries|Libraries}}

<p>If one is using a bundler, all the libraries installed via package manager, and imported into source code, will be automatically <i>bundled</i> into JavaScript code. Without a bundler it has to be done <em>manually</em>.</p>

<p>Upon installing a library we have to navigate to <code class="code">node_modules/_library_name_</code> directory. We should look for a compiled/bundled version of the library. Most of the libraries provide such a version, but not all of them - <strong>this is the major first issue we are going to encounter</strong>. We have to copy that already bundled source code into our directory that will be serving JS files for a browser.</p>

<p>I personally wrote a simple build script that runs TypeScript compilation, copies all the libraries etc.</p>

<p>In our code we are probably using libraries in following format:</p>

<code class="code-block language-js">import { groupBy } from 'lodash';</code>

<p>This code will be used by a browser, but the browser doesn't know what <code class="code">lodash</code> means. It will fail on importing it. It cannot resolve <code class="code">node_modules</code> like NodeJS do.</p>

<p>For that we use <a href="https://developer.mozilla.org/en-US/docs/Web/HTML/Element/script/type/importmap">importmap</a> in our HTML:</p>

<code class="code-block language-html">// index.html
&lt;script type="importmap"&gt;
  {
    "imports": {
      "lodash": "./lodash.min.js",
    }
  }
&lt;/script&gt;
</code>

<p>This will tell the browser, than whenever it is instructed to import <code class="code">lodash</code>, it should in fact load local path: <code class="code">./lodash.min.js</code>.</p>

{{h4|libraries-ts|Libraries with TypeScript}}

<p>Now, TypeScript might not work with libraries. For <code class="code">ESNext</code> modules (TypeScript configuration) it doesn't know where to look for them - they have to work in the browser which has different import resolution that TypeScript cannot automatically reason about.</p>

<p>But wait, we are already handling module resolution via <code class="code">importmap</code>! That means we need TypeScript to be able to resolve only typing. And we can do it using <code class="code">paths</code> in the <code class="code">tsconfig.json</code> file:</p>

<code class="code-block language-js">// tsconfig.json
{
  "paths": {
    "lodash": ["./node_modules/lodash/index.d.ts"], // or something similar
  }
}
</code>

<p>Now, whenever we import <code class="code">lodash</code>, TypeScript will know where its declaration file is.</p>

<p>Because paths corelate with <code class="code">importmap</code>, they will be extremely useful when our app grows.</p>

{{h3|esm-sh|esm.sh}}

<p>I almost forgot to mention that there is a CDN for ESM libraries called <a href="https://esm.sh/#docs">esm.sh</a> that allows you to write imports using HTTP protocol.</p>

<code class="code-block language-js"> // koteya.net syntax highlighting
import { common, createStarryNight } from 'https://esm.sh/@wooorm/starry-night@3?bundle';
import { toDom } from 'https://esm.sh/hast-util-to-dom@4?bundle';

const starryNight = await createStarryNight(common)
const prefix = 'language-'

const nodes = Array.from(document.body.querySelectorAll('code.code-block'))

for (const node of nodes) {
  const className = Array.from(node.classList).find(function (d) {
    return d.startsWith(prefix)
  })
  if (!className) continue
  const scope = starryNight.flagToScope(className.slice(prefix.length))
  if (!scope) continue
  const tree = starryNight.highlight(node.textContent, scope)
  node.replaceChildren(toDom(tree, {fragment: true}))
}
</code>

<p>It might <strong>very</strong> useful for <code class="code">importmap</code>, but I haven't tested it yet.</p>

{{h3|summary|Summary}}

<p>I'm not saying that bundlers are not useful, they certainly are. They manage assets, are usually bullet-proof, offer hot reloading, optimizations etc. But sometimes they are introduced when there is no actual need for them. Sometimes it's just enough to use things introduced by web standards only. The solution presented above <em>works</em>, but in certain cases it might be annoying (like in RxJS library case, which offers ESM build that you can copy, but it is invalid - it is not single-file build, and relative imports don't have extensions in paths, which makes that build unusuable for web). One might have to think hard around problems. There is beauty in that minimalistic approach, but it might not be for everyone. Hopefully JavaScript ecosystem and web standards will evolve to a point, when there will be no drawbacks, and all of that complex tooling will become obsolete.</p>